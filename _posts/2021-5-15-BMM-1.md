---
layout: post
title: Modifying Custom Matmul CUDA Kernel
---

I started to learn CUDA at the end of last year, and started writing matrix multiplication kernels as a learning project. After some struggles, I made it working, but then got really disappointed when I saw it's 10x slower than cuBLAS GEMM (I don't know what I was expecting to be honest). I've tried lots of open sourced matmul kernels on github, but the best one I found was still about 5 times slower (some of them were optimized towards older architectures). After few months of trial and error, my matmul kernel finally has comparable speed to cuBLAS GEMM.  
<details>  
  <summary markdown='span'>
    <b>Click here to see comparison:</b>
  </summary>  
  
### Square matrices: batch size = 1, m = n = k
![bmm_1](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/bmm_A%5B1%2CN%2CN%5D%20B%5B1%2CN%2CN%5D.png)  

### Batch size = 128, k = 128, varying m, n (m = n)
![bmm_2](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/bmm_A%5B128%2CN%2C128%5D%20B%5B128%2C128%2CN%5D.png)  
</details>

Maybe I will write a tutorial on matmul kernel optimization later, in this post I mainly want to talk about some interesting modifications that can be done on a matmul kernel.
- [Fused Reduce Matmul](#fused-reduce-matmul)
- [Nearest Neighbor Search](#nearest-neighbor-search)
- [Masked Batch Matmul](#masked-bmm)
- [Fused Attention](#fused-attention)  
 
## Fused Reduce Matmul
Sometimes we want to apply reduction right after a matrix multiplication:

{% highlight python %}  
C = torch.bmm(A, B)
maxC, argmaxC = torch.max(C, dim=1)
sumC = torch.sum(C, dim=2)
argminC = torch.argmin(C, dim=1)
{% endhighlight %}  

Normally there isn't a problem with doing this, however, when optimizing my implementation of K-means clustering algorithm, this become an issue. One of the main steps of K-means algorithm is computing the distance between every data point and every centroid (cluster center), and get index of the closest cluster for each data point (argmin).  

When the number of data point (n_data) and the number of clusters (n_clusters) are very large, this step will produce a huge (n_data x n_clusters) matrix that might not fit into GPU memory (imagine a 1,000,000 x 10,000 fp32 matrix)   

One workaround is to split this step into multiple tiny steps: in each step only compute the distance between a subset of data points and centroids, (let's say 10,000 x 10,000), asign each data point to the closest cluster, and repeat.  

A better way is to **fuse argmin into the matmul kernel**. Advantages of doing this are:  
1. No need to create huge matrices if the result of argmin is all we care about  
2. No need for loop  
3. Possibily faster (less memory ops).  

The K-Means implementation is [here](https://github.com/DeMoriarty/TorchPQ/tree/main/torchpq/kmeans), 
And [this](https://github.com/DeMoriarty/TorchPQ

## Nearest Neighbor Search
content  

## Masked BMM
Masked BMM (Batch Matrix Multiplication) means "hiding" some portion of the output of BMM using a binary mask. One example of this is the self-attention layer of GPT style language models. After computing dot product of queries and keys, we fill the upper triangular half of the output matrix with -âˆž. Here is how it's normally done in pytorch:  
```python
# shape of keys: [b, m, k]
# shape of values: [b, k, n]
# shape of mask: [m, n]
dot = torch.bmm(keys, queries)
dot.masked_fill_(mask = mask, value = float("-inf") )
```  
### Mask pattern

<img src="https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/mask2.png" width="30%" />

If we fuse masked_fill into the matmul kernel, we not only can get rid of masked_fill, but the matmul kernel itself can take advantage of the sparcity given by the mask (by not computing the masked part), reducing computation even further.  

The matmul kernel splits the output matrix C into a grid of 128 x 128 submatrices, each submatrix is assigned to a thread block. Each thread block consists of 256 threads, and each thread computes an 8 x 8 block of the 128 x 128 submatrix.  

First we need to do some preprocessing. We need 3 different levels of mask: block mask, thread mask and element mask. Block mask indicates which thread blocks should be ignored, and same goes for thread mask and element mask.  
```python
m, n = mask.shape
assert m % 128 == 0
assert n % 128 == 0

element_mask = mask
thread_mask = mask.view( m/8, 8, n/8, 8)
thread_mask = thread_mask.sum(dim=1).sum(dim=3)
block_mask = mask.view(m/128, 128, n/128, 128)
block_mask = block_mask.sum(dim=1).sum(dim=3)
```  
for simplicity, here we assume both m and n are fully divisible by 128.  

We input all 3 masks to the MBMM kernel:  
```C
extern "C"
__global__ void mbmm_nn(
  const float* __restrict__ A,
  const float* __restrict__ B,
  float* __restrict__ C,
  const uint8_t* __restrict__ BlockMask,   //
  const uint8_t* __restrict__ ThreadMask,  //
  const uint8_t* __restrict__ ElementMask, //
  int M, int N, int K
){
  ...
}
```
At the very start of the kernel, all threads within a thread block will read the block mask value, if it is 0, all threads within that thread block will exit.  (No memory store/loads, no arithmetic ops.)  
```C
int bN = (N + 128 - 1) / 128;
uint8_t block_mask = BlockMask[(blockIdx.y)*bN + (blockIdx.x)];
if (block_mask == 0){
  return;
}
```  

Each thread will also read a unique thread mask value:
```C
int vx = threadIdx.x % 16;
int vy = threadIdx.x / 16;
uint8_t thread_mask = ThreadMask[(blockIdx.y*16 + vy)*tN + (blockIdx.x*16 + vx) ];
```  
if it's 0, then that thread will skip the thread matmul step. 
```C
// main loop
for (int i=0; i<nItr; i++)
{
  ...
  
  if (thread_mask != 0){
    thread_matmul(aSM, bSM, cCache, vx, vy);
  }
  __syncthreads();
}
```  
However, all threads still participate in loading matrix A and B from global memory.

At the end of the kernel, before storing cached results to C, each thread will check its thread mask value once again, if it's between 0 and 64, that thread will mask the cached result using element mask.  
```C
if (0 < thread_mask < 64){
  mask_cCache(cCache, ElementMask, gStartx, gStarty, vx, vy, bid, M, N);
}
write_c(cCache, C, gStartx, gStarty, vx, vy, bid, M, N);
```  

This is similar to the idea of [Block Sparse](https://github.com/openai/blocksparse). The difference is we didn't design an entire new kernel for it, we just modified the existing matmul kernel.  

Now let's see how the new MBMM kernel performs compared to the original custom BMM + masked_fill and torch.bmm (cuBLAS) + masked_fill:
### 1. batch size = 128, m = n = 1024, varying k:
![mbmm_1](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/mbmm_A%5B128%2C1024%2CX%5D%20B%5B128%2CX%2C1024%5D.png)  

### 2. batch size = 128, k = 64, varying m, n (m = n):
![mbmm_2](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/mbmm_A%5B128%2CX%2C64%5D%20B%5B128%2C64%2CX%5D.png)  

### 3. m = n = 1024, k = 128, varying batch size:
![mbmm_3](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/mbmm_A%5BX%2C1024%2C128%5D%20B%5BX%2C128%2C1024%5D.png)  

We can see that, the new MBMM kernel has roughly 2 times the speed of the original BMM kernel + masked_fill, and 1.2 ~ 1.4 times the speed of torch.bmm + masked_fill.

## Fused Attention
content  
