---
layout: post
title: Modifying Custom Matmul CUDA Kernel
---

I started to learn CUDA at the end of last year, and started writing matrix multiplication kernels as a learning project. After some struggles, I made it working, but then got really disappointed when I saw it's 10x slower than cuBLAS GEMM (I don't know what I was expecting to be honest). I've tried lots of open sourced matmul kernels on github, but the best one I found was still about 5 times slower (some of them were optimized towards older architectures). After few months of trial and error, my matmul kernel finally has comparable speed to cuBLAS GEMM.  
<details markdown="1">  
  <summary markdown='span'>
    <b>Click here to see comparison:</b>
  </summary>  
  
### Square matrices: batch size = 1, m = n = k
![bmm_1](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/bmm_A%5B1%2CN%2CN%5D%20B%5B1%2CN%2CN%5D.png)  

### Batch size = 128, k = 128, varying m, n (m = n)
![bmm_2](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/bmm_A%5B128%2CN%2C128%5D%20B%5B128%2C128%2CN%5D.png)  
</details>

Maybe I will write a tutorial on matmul kernel optimization later, in this post I mainly want to talk about some interesting modifications that can be done on a matmul kernel.
- [Fused Reduce Matmul](#fused-reduce-matmul)
- [Nearest Neighbor Search](#nearest-neighbor-search)
- [Masked Batch Matmul](#masked-bmm)
- [Fused Attention](#fused-attention)  
 
## Fused Reduce Matmul
Sometimes we want to apply reduction right after a matrix multiplication:

```python
C = torch.bmm(A, B)
maxC, argmaxC = torch.max(C, dim=1)
sumC = torch.sum(C, dim=2)
argminC = torch.argmin(C, dim=1)
```

Normally there isn't a problem with doing this, however, when optimizing my implementation of K-means clustering algorithm, this become an issue. One of the main steps of K-means algorithm is computing the pairwise distance between every data point and every centroid (cluster center), and get index of the closest cluster for each data point (argmin).   

When the number of data points (n_data) and the number of clusters (n_clusters) are very large, this step will produce a huge (n_data x n_clusters) matrix that might not fit into the GPU memory (imagine a 1,000,000 x 10,000 fp32 matrix)   

One workaround is to split this step into multiple tiny steps: in each step only compute the distance between a subset of data points and centroids (let's say 10,000 x 10,000), then asign each data point to the closest cluster, and repeat.  

A better solution could be to **fuse argmin into the matmul kernel**. Advantages of doing this are:  
1. No need to create huge pairwise distance matrices if the result of argmin (or any type of reduction) is all we care about  
2. No need for a loop  
3. Possibily faster (less memory ops).  

The output tensor no longer needs to be `[b, m, n]`, it should be `[b, m]` or `[b, n]` depending on which dimention the reduction is performed on. And for min / max reduction, it makes sense to also do argmin / argmax at the same time. First allocate output tensors with pytorch:
```python
if dim == 1:
  values = torch.empty(b, n, device="cuda:0", dtype=torch.float32)
  indices = torch.empty(b, n, device="cuda:0", dtype=torch.int64)
elif dim == 2:
  values = torch.empty(b, m, device="cuda:0", dtype=torch.float32)
  indices = torch.empty(b, m, device="cuda:0", dtype=torch.int64)
```  

Fill `values` with -∞ for min (or ∞ for max):  
```python
values.fill_(float("-inf"))
```  

Then pass the pointer of the new output tensors and `dim` value to the cuda kernel. Now we are goint to edit the cuda kernel. First change the kernel name and parameters:
```cpp
typedef long long ll_t;
extern "C"
__global__ void min_bmm_nn(
  const float* __restrict__ A,
  const float* __restrict__ B,
  float* Values,
  ll_t* Indices,
  int M, int N, int K, int DIM
)
```  

We no longer need to cache 8 x 8 block of C in registers, instead, we need an array with length 8 to store the reduced values. For min + argmin or max + argmax, we also need another array to store indices of the min/max values.  
```cpp
// float8 cCache[8];
float valCache[8];
long_t idxCache[8];
```  


The K-Means implementation is [here](https://github.com/DeMoriarty/TorchPQ/tree/main/torchpq/kmeans), 
And [this](https://github.com/DeMoriarty/TorchPQ/blob/main/torchpq/kmeans/kernels/MaxSimKernel.cu) is the fused kernel. Maybe I will put them on this repo later.  

## Nearest Neighbor Search
content  

## Masked BMM
Masked BMM (Batch Matrix Multiplication) means "hiding" some portion of the output of BMM using a binary mask. One example of this is the self-attention layer of GPT style language models. After computing dot product of queries and keys, we fill the upper triangular half of the output matrix with -∞. Here is how it's normally done in pytorch:  
```python
# shape of keys: [b, m, k]
# shape of values: [b, k, n]
# shape of mask: [m, n]
dot = torch.bmm(keys, queries)
dot.masked_fill_(mask = mask, value = float("-inf") )
```  
### Mask pattern

<img src="https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/mask2.png" width="30%" />

If we fuse masked_fill into the matmul kernel, we not only can get rid of masked_fill, but the matmul kernel itself can take advantage of the sparcity given by the mask (by not computing the masked part), reducing computation even further.  

The matmul kernel splits the output matrix C into a grid of 128 x 128 submatrices, each submatrix is assigned to a thread block. Each thread block consists of 256 threads, and each thread computes an 8 x 8 block of the 128 x 128 submatrix.  

First we need to do some preprocessing. We need 3 different levels of mask: block mask, thread mask and element mask. Block mask indicates which thread blocks should be ignored, and same goes for thread mask and element mask.  
```python
m, n = mask.shape
assert m % 128 == 0
assert n % 128 == 0

element_mask = mask
thread_mask = mask.view( m/8, 8, n/8, 8)
thread_mask = thread_mask.sum(dim=1).sum(dim=3)
block_mask = mask.view(m/128, 128, n/128, 128)
block_mask = block_mask.sum(dim=1).sum(dim=3)
```  
for simplicity, here we assume both m and n are fully divisible by 128.  

We input all 3 masks to the MBMM kernel:  
```cpp
extern "C"
__global__ void mbmm_nn(
  const float* __restrict__ A,
  const float* __restrict__ B,
  float* __restrict__ C,
  const uint8_t* __restrict__ BlockMask,   //
  const uint8_t* __restrict__ ThreadMask,  //
  const uint8_t* __restrict__ ElementMask, //
  int M, int N, int K
){
  ...
}
```
At the very start of the kernel, all threads within a thread block will read the block mask value, if it is 0, all threads within that thread block will exit.  (No memory store/loads, no arithmetic ops.)  
```cpp
int bN = (N + 128 - 1) / 128;
uint8_t block_mask = BlockMask[(blockIdx.y)*bN + (blockIdx.x)];
if (block_mask == 0){
  return;
}
```  

Each thread will also read a unique thread mask value:
```cpp
int vx = threadIdx.x % 16;
int vy = threadIdx.x / 16;
uint8_t thread_mask = ThreadMask[(blockIdx.y*16 + vy)*tN + (blockIdx.x*16 + vx) ];
```  
if it's 0, then that thread will skip the thread matmul step. 
```cpp
// main loop
for (int i=0; i<nItr; i++)
{
  ...
  
  if (thread_mask != 0){
    thread_matmul(aSM, bSM, cCache, vx, vy);
  }
  __syncthreads();
}
```  
However, all threads still participate in loading matrix A and B from global memory.

At the end of the kernel, before storing cached results to C, each thread will check its thread mask value once again, if it's between 0 and 64, that thread will mask the cached result using element mask.  
```C
if (0 < thread_mask < 64){
  mask_cCache(cCache, ElementMask, gStartx, gStarty, vx, vy, bid, M, N);
}
write_c(cCache, C, gStartx, gStarty, vx, vy, bid, M, N);
```  

This is similar to the idea of [Block Sparse](https://github.com/openai/blocksparse). The difference is we didn't design an entire new kernel for it, we just modified the existing matmul kernel.  

Now let's see how the new MBMM kernel performs compared to the original custom BMM + masked_fill and torch.bmm (cuBLAS) + masked_fill:
<details markdown=1>  
  <summary>  
    <b>Click to show plots</b>
  </summary>  

### 1. batch size = 128, m = n = 1024, varying k:
![mbmm_1](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/mbmm_A%5B128%2C1024%2CX%5D%20B%5B128%2CX%2C1024%5D.png)  

### 2. batch size = 128, k = 64, varying m, n (m = n):
![mbmm_2](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/mbmm_A%5B128%2CX%2C64%5D%20B%5B128%2C64%2CX%5D.png)  

### 3. m = n = 1024, k = 128, varying batch size:
![mbmm_3](https://raw.githubusercontent.com/DeMoriarty/custom_matmul_kernels/main/imgs/mbmm_A%5BX%2C1024%2C128%5D%20B%5BX%2C128%2C1024%5D.png)  

</details>
We can see that, the new MBMM kernel has roughly 2 times the speed of the original BMM kernel + masked_fill, and 1.2 ~ 1.4 times the speed of torch.bmm + masked_fill.

## Fused Attention
content  
